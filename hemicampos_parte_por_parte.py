# -*- coding: utf-8 -*-
"""Hemicampos parte por parte.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1inHtA7yJsdzxz2dgP9h2pyfQYkb8ufQt

##Librerías
"""

#Instalo pylinac e importo todo lo que necesito
!pip install pylinac
import cv2
import datetime
from pylinac import PicketFence
import numpy as np
import matplotlib.pyplot as plt
import pydicom
import os
from google.colab import drive
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
from reportlab.platypus import Table
import tempfile
from pathlib import Path
from google.colab import files
#Conecto con mi drive y genero la ruta a mi carpeta de hemicampos
drive.mount('/content/drive')
my_directory = '/content/drive/My Drive/PPS - Intecnus/Python/HC(mío)'
os.makedirs(my_directory, exist_ok=True)

"""##def seleccionar_archivo_y_verificar_extension(directorio):"""

# Muestro los archivos en mi carpeta para elegir uno.
# Si no se analizo la imagen antes, la misma viene sin extensión, en ese caso se la
# agregamos. Si se elige un archivo que no es una imagen DICOM o el número que se eligio no está en la lista
# se vuelven a mostrar todos los archivos para que se vuelva a elegir. También guardo el nombre del archivo
# de mi imagen para usarlo en el nombre del pdf
def seleccionar_archivo_y_verificar_extension(directorio):
    archivos = os.listdir(directorio)
    if not archivos:
        print("No hay archivos en el directorio.")
        return None, None

    archivo_seleccionado = None
    while archivo_seleccionado is None:
        print("\nArchivos disponibles:")
        for i, archivo in enumerate(archivos):
            print(f"{i}: {archivo}")

        try:
            indice = int(input("\nSelecciona el número del archivo que deseas: "))
            if 0 <= indice < len(archivos):
                archivo_completo = archivos[indice]
                nombre_archivo, extension = os.path.splitext(archivo_completo)

                if extension == '.dcm':
                    ruta_final = os.path.join(directorio, archivo_completo)
                    print(f"El archivo ya tiene la extensión .dcm: {ruta_final}")

                elif extension != '':
                    print("El archivo seleccionado no se corresponde con una imagen DICOM.")
                    archivo_seleccionado = None
                    continue

                else:
                    ruta_original = os.path.join(directorio, archivo_completo)
                    ruta_final = os.path.join(directorio, archivo_completo + '.dcm')
                    os.rename(ruta_original, ruta_final)
                    print(f"Archivo renombrado a: {ruta_final}")

                return ruta_final, nombre_archivo
            else:
                print("El número seleccionado no es válido. Por favor, selecciona uno de los números mostrados.")
        except ValueError:
            print("Por favor, ingresa un número válido.")
### Esto lo saco del def main
ruta_final, nombre_archivo = seleccionar_archivo_y_verificar_extension(my_directory)
print(f"Proceso finalizado. Archivo seleccionado: {ruta_final}")

"""##def imagen_hemicampo(pixel_array):"""

#Genero la imagen de mi hemicampo para después ponerla en el pdf
def imagen_hemicampo(pixel_array):
    plt.figure(figsize=(4, 4))
    plt.imshow(pixel_array, cmap='gray')
    plt.title("Hemicampo analizado")
    plt.axis("off")

    #si quiero ver el gráfico
    #

    temp_file1 = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    plt.savefig(temp_file1.name, format='png', dpi=300, bbox_inches='tight', pad_inches=0)
    plt.show()
    plt.close()
    return temp_file1.name
### Esto lo saco del def main
imagen = ruta_final
dicom_image = pydicom.dcmread(imagen)
pixel_array = dicom_image.pixel_array
grafico_path1 = imagen_hemicampo(pixel_array)

"""##def defino_e_invierto_mi_cuadrado(pixel_array):"""

# Recorto mi imagen en un cuadrado probable que contenga mi campo cuadrado.
# Normalizo la imagen e invierto sus píxeles para practicidad del análisis.
def defino_e_invierto_mi_cuadrado(pixel_array):
    x, y, width, height = 253, 253, 524, 524
    normalizacion = cv2.normalize(pixel_array, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    inverted_pixel_array = 255 - normalizacion
    cuadrado = inverted_pixel_array[y:y+height, x:x+width]
    return cuadrado, inverted_pixel_array
###Esto lo saco del def main
cuadrado, inverted_pixel_array = defino_e_invierto_mi_cuadrado(pixel_array)
# Si quiero ver como queda mi cuadrado delimitado, ya normalizado e invertido
plt.figure(figsize=(4, 4))
plt.imshow(cuadrado, cmap='gray')
plt.title("Cuadrado probable")
#plt.axis("off")
plt.show()

"""##def binarizo_imagen(cuadrado, inverted_pixel_array):"""

# Binarizo mi imagen para buscar un cuadrado, uso un umbral para binarizar, este umbral lo saco de la imagen DICOM
# buscando el valor más oscuro de píxel cerca de los límites de mi cuadrado
def binarizo_imagen(cuadrado, inverted_pixel_array):
    x1, y1, width1, height1 = 320, 320, 300, 300
    borde = inverted_pixel_array[y1:y1+height1, x1:x1+width1]
    umbral = np.min(borde)
    _, binary_image = cv2.threshold(cuadrado, umbral, 255, cv2.THRESH_BINARY)
    return binary_image
### Esto lo saco del def main
binary_image = binarizo_imagen(cuadrado, inverted_pixel_array)
# Si quiero ver como queda mi imagen binarizada
plt.figure(figsize=(4, 4))
plt.imshow(binary_image, cmap='gray')
plt.title("Cuadrado binarizado")
plt.axis("off")
plt.show()

"""##def obtener_rotacion_y_centro_cuadrado(binary_image):"""

# Busco un cuadrado dentro de mi zona delimitada que es donde se supone que va a estar el campo cuadrado.
# Una vez que encuentra el campo cuadrado me va a dar su centro y si tiene alguna rotación.
def obtener_rotacion_y_centro_cuadrado(binary_image):
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    rotation_angle = None
    center = None

    for contour in contours:
        epsilon = 0.02 * cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, epsilon, True)

        if len(approx) == 4 and cv2.contourArea(approx) > 10000:
            rect = cv2.minAreaRect(contour)
            rotation_angle = rect[-1]

            if rotation_angle < -45:
                rotation_angle += 90

            if abs(rotation_angle) % 90 == 0:
                rotation_angle = 0

            M = cv2.moments(approx)
            center_x = int(M["m10"] / M["m00"])
            center_y = int(M["m01"] / M["m00"])
            center = (center_x, center_y)

            break
    return rotation_angle, center
### Esto lo saco del def main
angulo_rotacion, centro = obtener_rotacion_y_centro_cuadrado(binary_image)
#Si quiero saber los valores de ángulo y centro con respecto a mi cuadrado previamente definido
print(angulo_rotacion, centro)

"""##def hemicampo_x_o_y():"""

# Pregunto si el hemicampo es en x o en y. Si se ingresa un valor distinto vuelve a preguntar.
def hemicampo_x_o_y():
    while True:
        hemicampo = input("¿Es un hemicampo en 'x' o en 'y'? (x/y): ").strip().lower()
        if hemicampo in ['x', 'y']:
            return hemicampo
        else:
            print("Opción no válida. Por favor, ingresa 'x' o 'y'.")
### Esto lo saco del def main
hemicampo = hemicampo_x_o_y()

"""##def obtener_dimensiones_hemicampo(hemicampo, pixels_per_mm):"""

# Según si mi hemicampo es en x o en y defino las dimensiones del hemicampo que voy a analizar.
# Están las variables de ancho y alto en mm por si se quieren cambiar estos valores.
def obtener_dimensiones_hemicampo(hemicampo, pixels_per_mm):
    ancho_en_mm = 80
    alto_en_mm =140
    if hemicampo == 'y':
        ancho = ancho_en_mm * pixels_per_mm
        alto = alto_en_mm * pixels_per_mm
    else:
        ancho = alto_en_mm * pixels_per_mm
        alto = ancho_en_mm * pixels_per_mm
    return ancho, alto
### Esto lo saco del def main
pf = PicketFence(imagen)
pixels_per_mm = pf.image.dpmm
ancho, alto = obtener_dimensiones_hemicampo(hemicampo, pixels_per_mm)
# Si quiero saber los valores de ancho y alto en píxeles
print(ancho, alto)

"""##def recortar_roi(centro_detectado, inverted_pixel_array, ancho, alto):"""

# Según mi ancho y alto recorto mi región de interes de la imagen total.
def recortar_roi(centro_detectado, inverted_pixel_array, ancho, alto):
    x = int(centro_detectado[0] - ancho // 2)
    y = int(centro_detectado[1] - alto // 2)
    roi = inverted_pixel_array[y:y + int(alto), x:x + int(ancho)]
    return roi
### Esto lo saco del def main
centro_detectado = [centro[0] + 253, centro[1] + 253]
roi = recortar_roi(centro_detectado, inverted_pixel_array, ancho, alto)
# Si quiero ver como queda mi ROI
plt.figure(figsize=(4, 4))
plt.imshow(roi, cmap='gray')
plt.title("ROI")
plt.axis("off")
plt.show()

"""##def rotar_roi(roi, hemicampo):"""

# Si mi hemicampo es en x para facilitar mi análisis lo roto.
def rotar_roi(roi, hemicampo):
    if hemicampo == 'x':
        roi = cv2.rotate(roi, cv2.ROTATE_90_CLOCKWISE)
    return roi
### Esto lo saco del def main
roi = rotar_roi(roi, hemicampo)
# Si quiero ver como queda mi ROI
plt.figure(figsize=(4, 4))
plt.imshow(roi, cmap='gray')
plt.title("ROI")
plt.axis("off")
plt.show()

"""##def calcular_perfil_normalizado(roi, pixels_per_mm):"""

# Calculo mi perfil normalizado, para eso tomo un promedio de todas las filas de píxeles de mi imagen (para que
# tenga menos ruido el perfil) y convierto los píxeles en mm. Luego coloco el 0mm en el centro de mi imagen.
# Luego tomo un promedio de los 3 valores mínimos en mi imagen para establecer el cero. Y para determinar el 1
# tomo un promedio de todos los valores que hay entre 20 a 24mm de ambos lados, ya que se supone que allí se
# encuentra mi zona plana del perfil. Genero un gráfico de está normalización y lo guardo para ponerlo en el pdf.
# También guardo los valores de normalización.
# Están las variables de límites de normalización en mm por si se quieren cambiar estos valores.
def calcular_perfil_normalizado(roi, pixels_per_mm):
    row_means = np.mean(roi, axis=1)
    x_mm = np.arange(len(row_means)) / pixels_per_mm
    center_of_crossings = len(row_means) // 2
    x_mm -= x_mm[center_of_crossings]

    min_indices = np.argsort(row_means)[:3]
    avg_min = np.mean([row_means[index] for index in min_indices])

    limite_inf_norm = 20
    limite_sup_norm = 24
    indices_in_range = np.where(
        (x_mm >= limite_inf_norm) & (x_mm <= limite_sup_norm) |
        (x_mm <= -limite_inf_norm) & (x_mm >= -limite_sup_norm)
    )[0]
    x_selected = x_mm[indices_in_range]
    y_selected = row_means[indices_in_range]
    average_selected_points = np.mean(y_selected)
    normalized_row_means = (row_means - avg_min) / (average_selected_points - avg_min)
    normalized_y_selected = (y_selected - avg_min) / (average_selected_points - avg_min)

    plt.plot(x_mm, normalized_row_means, color='blue', label="Perfil normalizado")  # Perfil completo
    plt.scatter(x_selected, normalized_y_selected, color='red', label="Normalización")  # Puntos en el rango
    plt.axvline(x=-limite_inf_norm, color='green', linestyle='--', label=f"-{limite_inf_norm} mm")
    plt.axvline(x=-limite_sup_norm, color='green', linestyle='--', label=f"-{limite_sup_norm} mm")
    plt.axvline(x=limite_inf_norm, color='orange', linestyle='--', label=f"{limite_inf_norm} mm")
    plt.axvline(x=limite_sup_norm, color='orange', linestyle='--', label=f"{limite_sup_norm} mm")
    plt.title("Perfil")
    plt.xlabel("Posición horizontal (mm)")
    plt.ylabel("Intensidad normalizada")
    plt.grid(True)
    plt.legend()

    #si quiero ver el gráfico
    #plt.show()

    temp_file2 = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    plt.savefig(temp_file2.name, format='png', dpi=300)
    plt.close()
    return normalized_row_means, x_mm, temp_file2.name
### Esto lo saco del def main
normalized_row_means, x_mm, grafico_path2 = calcular_perfil_normalizado(roi, pixels_per_mm)

"""##def detectar_picos_valles(zona_plana_x, zona_plana_y):"""

# Busco el máximos(pico) y el mínimo(valle) en mi zona plana
def detectar_picos_valles(zona_plana_x, zona_plana_y):
    indice_pico_max = np.argmax(zona_plana_y)
    indice_valle_max = np.argmin(zona_plana_y)

    x_pico_max = zona_plana_y[indice_pico_max]
    y_pico_max = zona_plana_x[indice_pico_max]
    x_valle_max = zona_plana_y[indice_valle_max]
    y_valle_max = zona_plana_x[indice_valle_max]
    return x_pico_max, y_pico_max, x_valle_max, y_valle_max
### Esta función no esta en el main, sino que la uso en def procesar_hemicampo

"""##def procesar_hemicampo(centro_detectado, imagen, normalized_row_means, x_mm, hemicampo):"""

# Hago el análisis de hemicampos propiamente dicho. Delimito los límites de mi área a analizar(zona plana),
# hago uso de mi función detectar_picos_y_valles y según el hemicampo establezco los valores de error de 0,5mm
# y 1mm (definidos de forma experimental e interpolando), también puedo definir un ajuste para mi curva de error.
# Voy a obtener resultados y genero el gráfico de mi análisis para mi pdf.
# Dentro de mis resultados voy a tener posición, intensidad, desviación, desviación ajustada y según los valores
# de error voy a definir mis tolerancias. Cuando analice una imagen va a utilizar estas tolerancias para determinar
# la condición.
# Para realizar el análisis uso el valor con mayor desviación entre mi mínimo y mi máximo.
# Están las variables de límites de mi área a analizar en mm, errores y ajuste por si se quieren cambiar estos valores.
def procesar_hemicampo(centro_detectado, imagen, normalized_row_means, x_mm, hemicampo):
    lim_inf = -5
    lim_sup = 5

    indices_in_range = np.where((x_mm >= lim_inf) & (x_mm <= lim_sup))
    zona_plana_x = x_mm[indices_in_range]
    zona_plana_y = normalized_row_means[indices_in_range]
    y_pico_max, x_pico_max, y_valle_max, x_valle_max  = detectar_picos_valles(zona_plana_x, zona_plana_y)

    y_pico_porcentaje = abs(y_pico_max-1)*100
    y_valle_porcentaje = abs(y_valle_max-1)*100

    if hemicampo == 'y':
        #ajuste = 5.6
        ajuste = 0
        error_1_mm = 18.6
        error_05_mm = 10.7

    else:
        #ajuste = 3.2
        ajuste = 0
        error_1_mm = 13
        error_05_mm = 7.3

    y_pico_porcentaje_ajustado = y_pico_porcentaje-ajuste
    y_valle_porcentaje_ajustado = (-y_valle_porcentaje)-ajuste

    picos_y_valles = [y_pico_porcentaje_ajustado, abs(y_valle_porcentaje_ajustado)]
    max_ambos = np.max(picos_y_valles)
    if max_ambos == y_pico_porcentaje_ajustado:
        y_max_ambos = y_pico_max
        x_max_ambos = x_pico_max
        y_max_ambos_porcentaje = y_pico_porcentaje
    else:
        x_max_ambos = x_valle_max
        y_max_ambos = y_valle_max
        y_max_ambos_porcentaje = y_valle_porcentaje

    if max_ambos < error_05_mm:
        condicion = "Aceptable"
        color_condicion = "green"
    elif max_ambos < error_1_mm and max_ambos > error_05_mm:
        condicion = "Revisar"
        color_condicion = "orange"
    else:
        condicion = "Fuera de tolerancia"
        color_condicion = "red"

    plt.figure(figsize=(10, 6))
    plt.plot(zona_plana_x, zona_plana_y, label="Intensidades normalizadas", color='blue')
    plt.scatter(x_max_ambos, y_max_ambos, color='red', label="Máximo/mínimo detectado")
    plt.axhline(1, color='gray', linestyle='--', label="Referencia (y=1)")
    plt.xlabel("Posición (mm)")
    plt.ylabel("Intensidad normalizada")
    plt.title("Perfil en zona central")
    plt.legend()

    #si quiero ver el gráfico
    #plt.show()

    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    plt.savefig(temp_file.name, format='png', dpi=300)
    plt.close()

    resultados = {
        "Máximo/mínimo detectado": {
            "Posición": f"{round(x_max_ambos, 2)}mm",
            "Intensidad": f"{round(y_max_ambos, 2)}%",
            "Desviación": f"{round(y_max_ambos_porcentaje, 2)}%",
            "Desviación ajustada": f"{round(max_ambos, 2)}% (ajuste " + str(ajuste) + "%)"
        },
        "Condición": [condicion, color_condicion]
        }
    return temp_file.name, resultados, error_05_mm, error_1_mm
### Esto lo saco del def main
grafico_path, resultados, error_05_mm, error_1_mm = procesar_hemicampo(centro_detectado, inverted_pixel_array, normalized_row_means, x_mm, hemicampo)
# Si quiero ver los resultados
print(resultados)

"""##def Tolerancia (error_05_mm, error_1_mm):"""

# Armo mi texto de tolerancias para ponerlo después en el pdf
def Tolerancia (error_05_mm, error_1_mm):
      tolerancia = {
          "Valores de tolerancia y acción": {
              "Aceptable menor a ": error_05_mm,
              "Revisar menor a ": error_1_mm,
              "Fuera de tolerancia mayor o igual a ": error_1_mm
          }
      }
      return tolerancia
### Esto lo saco del def main
tolerancias = Tolerancia(error_05_mm, error_1_mm)
# Si quiero ver las tolerancias
print(tolerancias)

"""##def Metadata(imagen):"""

# Utilizo los metadatos de mi imagen DICOM para saber en que fech y hora fue realizada la imagen.
# Los guardo para ponerlos en el pdf.
def Metadata(imagen):
    dicom_dataset = pydicom.dcmread(imagen)
    fecha_cruda = dicom_dataset.StudyDate
    fecha = fecha_cruda[:4] + "." + fecha_cruda[4:6] + "." + fecha_cruda[6:]
    hora_cruda = dicom_dataset.StudyTime
    hora = hora_cruda[:2] + ":" + hora_cruda[2:4]
    return fecha, hora
### Esto lo saco del def main
fecha, hora = Metadata(imagen)
metadata = "Fecha de la imagen: " + fecha + "; " + hora
# Si quiero ver la fecha y hora
print(metadata)

"""##def publish_pdf(filename: str, tolerancias: str = None, metadata: dict = None, logo: Path = None, grafico_path: str = None, grafico_path1: str = None, grafico_path2: str = None, resultados: dict = None, titulo: dict = None, rotacion: dict = None):"""

# Genero el PDF con todo lo que fuí armando antes.
def publish_pdf(filename: str, tolerancias: str = None, metadata: dict = None, logo: Path = None, grafico_path: str = None, grafico_path1: str = None, grafico_path2: str = None, resultados: dict = None, titulo: dict = None, rotacion: dict = None):
    doc = SimpleDocTemplate(filename, pagesize=letter)
    story = []
    styles = getSampleStyleSheet()
    page_width, page_height = letter

    if titulo:
        story.append(Paragraph(titulo, styles['h1']))
        story.append(Spacer(1, 12))

    if metadata:
        story.append(Paragraph(metadata, styles['Normal']))
        story.append(Spacer(1, 12))

    if logo and Path(logo).exists():
        img = Image(logo, width=1 * inch, height=1 * inch)
        img.hAlign = 'RIGHT'
        story.insert(0, img)
        story.append(Spacer(1, 12))

    if grafico_path2 and Path(grafico_path2).exists() and grafico_path1 and Path(grafico_path1).exists():
        grafico1 = Image(grafico_path1, width=4 * inch, height=4 * inch)
        grafico2 = Image(grafico_path2, width=4.5 * inch, height=4 * inch)

        data = [[grafico1, grafico2]]
        table = Table(data)
        story.append(table)
        story.append(Spacer(1, 6))

    if grafico_path and Path(grafico_path).exists():
        grafico = Image(grafico_path, width=6 * inch, height=4 * inch)
        story.append(grafico)
        story.append(Spacer(1, 12))

    if resultados:
        story.append(Paragraph("Resultados del análisis:", styles['h2']))
        for key, value in resultados.items():
            story.append(Spacer(1, 1))
            story.append(Paragraph(f"<b>{key}:</b>", styles['Normal']))

            if isinstance(value, dict):
                for subkey, subvalue in value.items():
                    story.append(Paragraph(f"{subkey}: {subvalue}", styles['Normal']))

            elif isinstance(value, list):
                condicion_text = value[0]
                condicion_color = value[1]
                condicion_paragraph = Paragraph(f"<font color='{condicion_color}'>{condicion_text}</font>", styles['Normal'])
                story.append(condicion_paragraph)

    if tolerancias:
        story.append(Paragraph("Tolerancias:", styles['h2']))
        for key, value in tolerancias.items():
            story.append(Spacer(1, 1))
            story.append(Paragraph(f"<b>{key}:</b>", styles['Normal']))
            if isinstance(value, dict):
                for subkey, subvalue in value.items():
                    story.append(Paragraph(f"{subkey} {subvalue}", styles['Normal']))
            else:
                story.append(Paragraph(f"{value}", styles['Normal']))
        story.append(Spacer(1, 6))

    if rotacion:
        story.append(Paragraph("Notas:", styles['h2']))
        story.append(Paragraph(rotacion, styles['Normal']))
        story.append(Spacer(1, 12))
    doc.build(story)
### Esto lo saco del def main
titulo = "Análisis de Hemicampo en " + hemicampo.upper()
rotacion = f"Rotación: {round(angulo_rotacion, 2)}°"
logo_path = os.path.join(my_directory, 'logo.png')
current_datetime = datetime.datetime.now()
formatted_datetime = current_datetime.strftime("%Y-%m-%d")
pdf_path = os.path.join(my_directory, f"Hemicampo {nombre_archivo} {formatted_datetime}.pdf")
publish_pdf(pdf_path, tolerancias=tolerancias, metadata=metadata, logo=logo_path,grafico_path1=grafico_path1, grafico_path2=grafico_path2, grafico_path=grafico_path, resultados=resultados, titulo=titulo, rotacion=rotacion)
files.download(pdf_path)

"""##def main():"""

def main():
    ruta_final, nombre_archivo = seleccionar_archivo_y_verificar_extension(my_directory)
    print(f"Proceso finalizado. Archivo seleccionado: {ruta_final}")
    imagen = ruta_final
    dicom_image = pydicom.dcmread(imagen)
    pixel_array = dicom_image.pixel_array
    grafico_path1 = imagen_hemicampo(pixel_array)
    cuadrado, inverted_pixel_array = defino_e_invierto_mi_cuadrado(pixel_array)
    binary_image = binarizo_imagen(cuadrado, inverted_pixel_array)
    angulo_rotacion, centro = obtener_rotacion_y_centro_cuadrado(binary_image)
    hemicampo = hemicampo_x_o_y()

    # Cargo la imagen con PicketFence para obtener el valor píxeles por mm
    pf = PicketFence(imagen)
    pixels_per_mm = pf.image.dpmm
    ancho, alto = obtener_dimensiones_hemicampo(hemicampo, pixels_per_mm)

    # Como el centro que detecto es respecto al cuadrado que tome, le agrego los píxeles que le había recortado
    # al definir mi cuadrado, para así obtener el centro respecto a la imagen completa.
    centro_detectado = [centro[0] + 253, centro[1] + 253]
    roi = recortar_roi(centro_detectado, inverted_pixel_array, ancho, alto)
    roi = rotar_roi(roi, hemicampo)
    normalized_row_means, x_mm, grafico_path2 = calcular_perfil_normalizado(roi, pixels_per_mm)
    grafico_path, resultados, error_05_mm, error_1_mm = procesar_hemicampo(centro_detectado, inverted_pixel_array, normalized_row_means, x_mm, hemicampo)

    # Parámetros para mi pdf
    titulo = "Análisis de Hemicampo en " + hemicampo.upper()
    fecha, hora = Metadata(imagen)
    metadata = "Fecha de la imagen: " + fecha + "; " + hora
    rotacion = f"Rotación: {round(angulo_rotacion, 2)}°"
    tolerancias = Tolerancia(error_05_mm, error_1_mm)
    logo_path = os.path.join(my_directory, 'logo.png')
    current_datetime = datetime.datetime.now()
    formatted_datetime = current_datetime.strftime("%Y-%m-%d")

    # Genero el pdf y lo descargo en el equipo
    pdf_path = os.path.join(my_directory, f"Hemicampo {nombre_archivo} {formatted_datetime}.pdf")
    publish_pdf(pdf_path, tolerancias=tolerancias, metadata=metadata, logo=logo_path,grafico_path1=grafico_path1, grafico_path2=grafico_path2, grafico_path=grafico_path, resultados=resultados, titulo=titulo, rotacion=rotacion)
    files.download(pdf_path)