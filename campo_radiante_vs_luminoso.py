# -*- coding: utf-8 -*-
"""Campo Radiante vs Luminoso.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Ofoh6MmxH3L-MRLBk7oPDVdf4AcTk1v
"""

#Instalo pylinac e importo todo lo que necesito
!pip install pylinac
import cv2
from pylinac import PicketFence
import numpy as np
import matplotlib.pyplot as plt
import pydicom
import os
import datetime
from google.colab import drive
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, PageBreak
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
from reportlab.platypus import Table
import tempfile
from pathlib import Path
#Conecto con mi drive y genero la ruta a mi carpeta de CLvsCR
drive.mount('/content/drive')
my_directory = '/content/drive/My Drive/PPS - Intecnus/Python/CLvsCR'
os.makedirs(my_directory, exist_ok=True)

# Muestro los archivos en mi carpeta para elegir uno.
# Si no se analizo la imagen antes, la misma viene sin extensión, en ese caso se la
# agregamos. Si se elige un archivo que no es una imagen DICOM o el número que se eligio no está en la lista
# se vuelven a mostrar todos los archivos para que se vuelva a elegir.
def seleccionar_archivo_y_verificar_extension(directorio, mensaje):
    archivos = os.listdir(directorio)
    if not archivos:
        print("No hay archivos en el directorio.")
        return None, None
    archivo_seleccionado = None
    while archivo_seleccionado is None:
        print("\nArchivos disponibles:")
        for i, archivo in enumerate(archivos):
            print(f"{i}: {archivo}")
        try:
            indice = int(input("\nSelecciona el número del archivo que deseas" + mensaje))
            if 0 <= indice < len(archivos):
                archivo_seleccionado = archivos[indice]

                if archivo_seleccionado.endswith('.dcm'):
                    ruta_final = os.path.join(directorio, archivo_seleccionado)
                    print(f"El archivo ya tiene la extensión .dcm: {ruta_final}")

                elif '.' in archivo_seleccionado:
                    print("El archivo seleccionado no se corresponde con una imagen DICOM.")
                    archivo_seleccionado = None
                    continue

                else:
                    ruta_original = os.path.join(directorio, archivo_seleccionado)
                    ruta_final = os.path.join(directorio, archivo_seleccionado + '.dcm')
                    os.rename(ruta_original, ruta_final)
                    print(f"Archivo renombrado a: {ruta_final}")

                nombre_archivo = os.path.splitext(archivo_seleccionado)[0]
                print(f"Proceso finalizado. Archivo seleccionado: {ruta_final}")
                return ruta_final, nombre_archivo

            else:
                print("El número seleccionado no es válido. Por favor, selecciona uno de los números mostrados.")
        except ValueError:
            print("Por favor, ingresa un número válido.")
# Genero la imagen de mi campo radiante para después ponerla en el pdf
def imagen(pixel_array, titulo):
    plt.figure(figsize=(4, 4))
    plt.imshow(pixel_array, cmap='gray')
    plt.title(titulo)
    plt.axis("on")
    temp_file1 = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    plt.savefig(temp_file1.name, format='png', dpi=300)
    plt.close()
    return temp_file1.name
# Utilizo los metadatos de mi imagen DICOM para saber en que fecha y hora fue realizada la imagen.
# Los guardo para ponerlos en el pdf.
def Metadata(imagen):
    dicom_dataset = pydicom.dcmread(imagen)
    fecha_cruda = dicom_dataset.StudyDate
    fecha = fecha_cruda[:4] + "." + fecha_cruda[4:6] + "." + fecha_cruda[6:]
    hora_cruda = dicom_dataset.StudyTime
    hora = hora_cruda[:2] + ":" + hora_cruda[2:4]
    return fecha, hora
# Para lograr detectar los fiduciales del maniquí voy a binarizar la imagen, lo hago a partir de
# de un histograma de la imagen, buscando el valor más frecuente. Uso un ajuste porque sino binariza mal.
# El valor de ajuste se modifica directamente en esta función.
def binarizar_por_moda(imagen, ajuste=10):
    histograma, _ = np.histogram(imagen.ravel(), bins=256, range=[0, 256])
    valor_mas_frecuente = np.argmax(histograma)
    umbral_moda = max(0, valor_mas_frecuente - ajuste)
    _, imagen_bin_moda = cv2.threshold(imagen, umbral_moda, 255, cv2.THRESH_BINARY)
    normalizacion = cv2.normalize(imagen_bin_moda, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    inv_imagen_bin_moda = 255 - normalizacion
    return inv_imagen_bin_moda
# En la imagen binarizada, uso momentos para detectar el centro de la figura (el fiducial).
def detectar_centro_por_momentos(roi, cx, cy):
    moments = cv2.moments(roi)
    if moments["m00"] != 0:
        cX = int(moments["m10"] / moments["m00"])
        cY = int(moments["m01"] / moments["m00"])
        avg_center = (cX, cY)
        avg_center = (cX + cx, cY + cy)
        return avg_center
    else:
        print("No se pudo encontrar el centro por momento.")
        return None
# Recorto una zona donde suponemos que va a estar mi campo luminoso (13x13cm tomando el centro de la imagen).
# Invierto la imagen para facilitar el análisis.
def defino_e_invierto_mi_cuadrado_10x10(pixel_array):
    x, y, width, height = 253, 253, 524, 524
    normalizacion = cv2.normalize(pixel_array, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    inverted_pixel_array = 255 - normalizacion
    cuadrado = inverted_pixel_array[y:y+height, x:x+width]
    return cuadrado, inverted_pixel_array,x, y
# Aplicar filtro de mediana para eliminar líneas verticales / mejorar la detección de los BB's
def filtro_medianBlur(imagen, kernel_size=3):
    imagen_filtrada = cv2.medianBlur(imagen, kernel_size)
    return imagen_filtrada
# Recorto una zona donde suponemos que va a estar mi campo luminoso (22x22cm tomando el centro de la imagen).
# Invierto la imagen para facilitar el análisis.
def defino_e_invierto_mi_cuadrado_20x20(pixel_array):
    x, y, width, height = 70, 70, 880, 880
    normalizacion = cv2.normalize(pixel_array, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    inverted_pixel_array = 255 - normalizacion
    cuadrado = inverted_pixel_array[y:y+height, x:x+width]
    return cuadrado, inverted_pixel_array, x, y
# Recorto la imagen para crear mi roi que va a contener mi ROI de interes para definir las dimensiones de mi campo radiante.
def crear_roi_y_procesar(pixel_array, x, y, width, height, titulo):
  roi = pixel_array[y:y+height, x:x+width]
  roi_normalizada = cv2.normalize(roi, None, alpha=0, beta=255,
                                  norm_type=cv2.NORM_MINMAX,
                                  dtype=cv2.CV_8U)
  roi_invertida = 255 - roi_normalizada
  return roi_invertida
# Defino mis vértices del campo radiante a partir del centro, ancho y alto detectados con FWHM.
# Me da la lista de vértices en tipo int32.
def vertices_radiantes(centro, ancho, alto):
    x_centro, y_centro = centro
    x1 = int(x_centro - ancho / 2)
    y1 = int(y_centro - alto / 2)
    x2 = int(x_centro + ancho / 2)
    y2 = int(y_centro + alto / 2)
    vertices = np.array([[x1, y1], [x2, y1], [x2, y2], [x1, y2]], dtype=np.int32)
    return vertices
# Calculo el rango de datos que voy a tener que ignorar para realizar el análisis del
# campo radiante de 20x20. Esto lo hago quitando los datos que superan el FWHM.
# Estos son los que van a corresponder al campo radiante de 10x10 porque en ese campo
# la dosis va a ser el doble que en el de 20x20.
def calcular_rango_a_ignorar(roi, orientacion):
    if orientacion == 'vertical':
        perfil_intensidad = np.mean(roi, axis=1)
        x_px = np.arange(perfil_intensidad.shape[0])
    elif orientacion == 'horizontal':
        perfil_intensidad = np.mean(roi, axis=0)
        x_px = np.arange(perfil_intensidad.shape[0])
    else:
        raise ValueError("La orientación debe ser 'horizontal' o 'vertical'.")
    max_intensity = np.max(perfil_intensidad)
    half_max = max_intensity / 2
    indices = np.where(perfil_intensidad >= half_max)[0]

    if len(indices) > 0:
        fwhm_start = indices[0]
        fwhm_end = indices[-1]
        rango_a_ignorar = (fwhm_start, fwhm_end)
    else:
        rango_a_ignorar = None
    return rango_a_ignorar
# Según la orientación que tenga la imagen se van a analizar las filas o columnas de la imagen
# promediando todos los valores y se va a obtener la FWHM. Esta me va a servir para determinar
# el ancho o el alto de mi campo radiante, según corresponda y también me va a dar el centro del mismo.
# Si se le especifica va a ignorar un rango de datos (lo uso para el campo de 20x20).
def calcular_fwhm_y_perfil_promediado(roi, orientacion, rango_a_ignorar=None):
    if orientacion == 'horizontal':
        perfil_promediado = np.mean(roi, axis=0)
        x_px = np.arange(perfil_promediado.shape[0])
    elif orientacion == 'vertical':
        perfil_promediado = np.mean(roi, axis=1)
        x_px = np.arange(perfil_promediado.shape[0])
    else:
        raise ValueError("La orientación debe ser 'horizontal' o 'vertical'.")

    perfil_original = perfil_promediado.copy()

    if rango_a_ignorar is not None:
        inicio, fin = rango_a_ignorar
        perfil_promediado[inicio:fin] = np.nan

    max_intensity = np.nanmax(perfil_promediado)
    half_max = max_intensity / 2
    indices = np.where(np.nan_to_num(perfil_promediado) >= half_max)[0]

    if len(indices) > 0:
        fwhm_start = indices[0]
        fwhm_end = indices[-1]
        fwhm_px = fwhm_end - fwhm_start
        centro_fwhm_px = (fwhm_start + fwhm_end) / 2
    else:
        fwhm_px = None
        centro_fwhm_px = None
    return fwhm_px, centro_fwhm_px
# Se comparan los campos luminosos y radiantes, para esto se calcula la distancia entre los centros como:
# r = √[(Xcr-Xcl)2+(Ycr-Ycl)2]
# También se comparan las distancias entre los vértices como un único valor de RMS como:
# RMS = √{(1/4)*Σ[(Xvr-Xvl)2+(Yvr-Yvl)2]}
# Se genera el listado de resultados para agregarlos luego al pdf.
def comparar_cuadrados_luminoso_vs_radiante(imagen, vertices_10x10_lum, vertices_10x10_rad, vertices_20x20_lum, vertices_20x20_rad, dx_10x10, dy_10x10, dx_20x20, dy_20x20, pixels_per_mm, centro_aceptable, centro_revisar, vertices_aceptable, vertices_revisar):
    if imagen.dtype == np.uint16:
        imagen = (imagen / 256).astype(np.uint8)

    if len(imagen.shape) == 2 or imagen.shape[2] == 1:
        imagen = cv2.cvtColor(imagen, cv2.COLOR_GRAY2BGR)

    imagen_superpuesta = imagen.copy()

    cuadrados = [
        (vertices_10x10_lum, vertices_10x10_rad, dx_10x10, dy_10x10, (0, 255, 0)),
        (vertices_20x20_lum, vertices_20x20_rad, dx_20x20, dy_20x20, (255, 255, 0))
    ]

    diferencias_centros = {}
    diferencias_rms = {}

    for i, (vertices_lum, vertices_rad, dx, dy, color) in enumerate(cuadrados):
        vertices_lum_mod = vertices_lum + np.array([[dx, dy]])
        cv2.polylines(imagen_superpuesta, [vertices_lum_mod], isClosed=True, color=color, thickness=2)

        centro_lum = (int(np.mean(vertices_lum_mod[:, 0, 0])), int(np.mean(vertices_lum_mod[:, 0, 1])))
        centro_rad = (int(np.mean(vertices_rad[:, 0])), int(np.mean(vertices_rad[:, 1])))

        cv2.circle(imagen_superpuesta, centro_lum, 1, (0, 0, 255), -1)
        cv2.circle(imagen_superpuesta, centro_rad, 1, (255, 0, 0), -1)

        diferencia_centros = (
            abs(centro_lum[0] - centro_rad[0]) / pixels_per_mm,
            abs(centro_lum[1] - centro_rad[1]) / pixels_per_mm
        )

        diferencias = np.linalg.norm(vertices_lum_mod[:, 0] - vertices_rad, axis=1)
        diferencia_rms = np.sqrt(np.mean(diferencias**2)) / pixels_per_mm

        key = "10x10" if i == 0 else "20x20"
        diferencias_centros[key] = diferencia_centros
        diferencias_rms[key] = diferencia_rms

    radio_10x10 = np.sqrt(diferencias_centros['10x10'][0]**2 + diferencias_centros['10x10'][1]**2)
    radio_20x20 = np.sqrt(diferencias_centros['20x20'][0]**2 + diferencias_centros['20x20'][1]**2)

    if radio_10x10 < centro_aceptable and radio_20x20 < centro_aceptable:
        condicion_c = "Aceptable"
        color_condicion_c = "green"
    elif radio_10x10 >= centro_revisar or radio_20x20 >= centro_revisar:
        condicion_c = "Fuera de tolerancia"
        color_condicion_c = "red"
    else:
        condicion_c = "Revisar"
        color_condicion_c = "orange"

    if diferencias_rms['10x10'] < vertices_aceptable and diferencias_rms['20x20'] < vertices_aceptable:
        condicion_v = "Aceptable"
        color_condicion_v = "green"
    elif diferencias_rms['10x10'] >= vertices_revisar or diferencias_rms['20x20'] >= vertices_revisar:
        condicion_v = "Fuera de tolerancia"
        color_condicion_v = "red"
    else:
        condicion_v = "Revisar"
        color_condicion_v = "orange"

    resultados = {
        "Diferencia entre centros de campos Radiantes vs Luminosos (x, y, r)": {
            "Dif. campo de 10x10cm²": f"{round(diferencias_centros['10x10'][0], 2)}mm" + ", " + f"{round(diferencias_centros['10x10'][1], 2)}mm" + ", " + f"{round(radio_10x10, 2)}mm",
            "Dif. campo de 20x20cm²": f"{round(diferencias_centros['20x20'][0], 2)}mm" + ", " + f"{round(diferencias_centros['20x20'][1], 2)}mm" + ", " + f"{round(radio_20x20, 2)}mm",
            "Condición: ": [condicion_c, color_condicion_c]
        },
        "Diferencia entre vértices de campos Radiantes vs Luminosos (RMS)": {
            "Dif. campo de 10x10cm²": f"{round(diferencias_rms['10x10'], 2)}mm",
            "Dif. campo de 20x20cm²": f"{round(diferencias_rms['20x20'], 2)}mm",
            "Condición: ": [condicion_v, color_condicion_v]
        }}

    return imagen_superpuesta, resultados
# De forma adicional se comparan los centros entre los campos de 10x10 y 20x20, tanto
# radiantes como luminosos.
# El resultado es únicamente la distancia entre los centros.
def comparar_centros_cuadrados(vertices_10x10_lum, vertices_10x10_rad, vertices_20x20_lum, vertices_20x20_rad, dx_10x10, dy_10x10, dx_20x20, dy_20x20, pixels_per_mm):
    vertices_10x10_lum_mod = vertices_10x10_lum + np.array([[dx_10x10, dy_10x10]])
    vertices_20x20_lum_mod = vertices_20x20_lum + np.array([[dx_20x20, dy_20x20]])

    centro_10x10_lum = (int(np.mean(vertices_10x10_lum_mod[:, 0, 0])),
                        int(np.mean(vertices_10x10_lum_mod[:, 0, 1])))

    centro_20x20_lum = (int(np.mean(vertices_20x20_lum_mod[:, 0, 0])),
                        int(np.mean(vertices_20x20_lum_mod[:, 0, 1])))

    centro_10x10_rad = (int(np.mean(vertices_10x10_rad[:, 0])),
                        int(np.mean(vertices_10x10_rad[:, 1])))

    centro_20x20_rad = (int(np.mean(vertices_20x20_rad[:, 0])),
                        int(np.mean(vertices_20x20_rad[:, 1])))

    def diferencia_mm(centro1, centro2):
        return (abs(centro1[0] - centro2[0]) / pixels_per_mm,
                abs(centro1[1] - centro2[1]) / pixels_per_mm)
    diferencia_rad = diferencia_mm(centro_10x10_rad, centro_20x20_rad)
    diferencia_lum = diferencia_mm(centro_10x10_lum, centro_20x20_lum)
    return diferencia_lum, diferencia_rad
# En una sola función hago todo el procesamiento de mi imagen recortada con el fiducial.
# Le aplico un filtro de mediana para mejorar la detección, binarizo y busco el centro.
# Proceso los 4 fiduciales en una sola función.
def procesar_fiducial(pixel_array, coords_rois, defino_e_invierto_mi_cuadrado, pixels_per_mm):
    cuadrado, _, x_cuadrado, y_cuadrado = defino_e_invierto_mi_cuadrado(pixel_array)
    rois = []
    centros = []
    for i, (x, y, width, height) in enumerate(coords_rois):
        roi = cuadrado[y:y + height, x:x + width]
        rois.append(roi)
        roi_filtrada = filtro_medianBlur(roi)
        roi_inv = binarizar_por_moda(roi_filtrada)
        centro = detectar_centro_por_momentos(roi_inv, x, y)
        centros.append(centro)
    vertices = np.array(centros, dtype=np.int32).reshape((-1, 1, 2))
    return vertices, cuadrado, x_cuadrado, y_cuadrado
# Recorto el campo radiante (tanto de 10x10 como 20x20) para poder analizarlo con FWHM.
# Para eso según quiera calcular el ancho o el alto voy a necesitar una roi diferente,
# utilizo titulo para diferenciarlas.
def recortar_y_nombrar_rois_radlum(pixel_array_radlum, coords_rois_10x10, coords_rois_20x20):
  roi_perfil_inv_10x10_ancho, roi_perfil_inv_10x10_alto = None, None
  for x, y, width, height, titulo in coords_rois_10x10:
    roi_invertida = crear_roi_y_procesar(pixel_array_radlum, x, y, width, height, titulo)
    if titulo == "ROI perfil invertido 10x10 ancho":
      roi_perfil_inv_10x10_ancho = roi_invertida
    elif titulo == "ROI perfil invertido 10x10 alto":
      roi_perfil_inv_10x10_alto = roi_invertida

  roi_perfil_inv_20x20_ancho, roi_perfil_inv_20x20_alto = None, None
  for x, y, width, height, titulo in coords_rois_20x20:
    roi_invertida_20x20 = crear_roi_y_procesar(pixel_array_radlum, x, y, width, height, titulo)
    if titulo == "ROI perfil invertido 20x20 ancho":
      roi_perfil_inv_20x20_ancho = roi_invertida_20x20
    elif titulo == "ROI perfil invertido 20x20 alto":
      roi_perfil_inv_20x20_alto = roi_invertida_20x20
  return roi_perfil_inv_10x10_ancho, roi_perfil_inv_10x10_alto, roi_perfil_inv_20x20_ancho, roi_perfil_inv_20x20_alto
# Armo mi texto de tolerancias para ponerlo después en el pdf.
def Tolerancia(centro_aceptable, centro_revisar, vertices_aceptable, vertices_revisar):
    tolerancia = {
        "Valores de tolerancia y acción": {
            "Aceptable menor a:": str(centro_aceptable) + "mm para radio (r) y " + str(vertices_aceptable) + "mm para RMS.",
            "Revisar menor a:": str(centro_revisar) + "mm para radio (r) y " + str(vertices_revisar) + "mm para RMS.",
            "Fuera de tolerancia mayor o igual a:": str(centro_revisar) + "mm para radio (r) y " + str(vertices_revisar) + "mm para RMS.",
        }
    }
    return tolerancia
# Defino las tolerancias de aceptación y de revisión.
# Tanto para los centros como para los vértices, los valores son en mm.
def definicion_tolerancias():
    centro_aceptable = 1
    centro_revisar = 2
    vertices_aceptable = 1.5
    vertices_revisar = 2
    return centro_aceptable, centro_revisar, vertices_aceptable, vertices_revisar
# En notas voy a informar sobre la diferencia entre los campos de 20x20 y 10x10.
# Armo el texto para el pdf.
def Notas(dif_lum, dif_rad):
    nota = {
        "Diferencia entre los centros de los campos de 10x10cm² y 20x20cm² (x, y)": {
            "Campos luminosos:": f"{dif_lum[0]:.2f}mm, {dif_lum[1]:.2f}mm",
            "Campos radiantes:": f"{dif_rad[0]:.2f}mm, {dif_rad[1]:.2f}mm",
        },
        "Nota sobre la imagen con ambos campos: ":"El centro del campo radiante se dibuja como un punto rojo y el centro del campo luminoso como un punto azul."
    }
    return nota
# Armo el texto de las ecuaciones que utilice para el pdf.
def Ecuaciones():
    ecuaciones = {
            "• Para el análisis de las diferencias entre los centros de campos, se calcula la distancia (r) entre centros, como: ": "r = √[(Xcr-Xcl)²+(Ycr-Ycl)²]",
            "• Para el análisis de las diferencias entre los vértices de campos, se calcula el RMS (Root Mean Square) de los cuatro vértices de cada campo, como: ": "RMS = √{(1/4)*Σ[(Xvr-Xvl)²+(Yvr-Yvl)²]}",
        }
    return ecuaciones

# Genero el PDF con todo lo que fuí armando antes.
def publish_pdf(filename: str, tolerancias: str = None, ecuaciones: dict = None, metadata: dict = None, logo: Path = None, grafico_path1: str = None, grafico_path2: str = None, resultados: dict = None, titulo: dict = None, notas: dict = None):
    doc = SimpleDocTemplate(filename, pagesize=letter)
    story = []
    styles = getSampleStyleSheet()
    page_width, page_height = letter

    if titulo:
        story.append(Paragraph(titulo, styles['h1']))
        story.append(Spacer(1, 12))

    if metadata:
        story.append(Paragraph(metadata, styles['Normal']))
        story.append(Spacer(1, 12))

    if logo and Path(logo).exists():
        img = Image(logo, width=1 * inch, height=1 * inch)
        img.hAlign = 'RIGHT'
        story.insert(0, img)
        story.append(Spacer(1, 12))

    if grafico_path2 and Path(grafico_path2).exists() and grafico_path1 and Path(grafico_path1).exists():
        grafico1 = Image(grafico_path1, width=4 * inch, height=4 * inch)
        grafico2 = Image(grafico_path2, width=4 * inch, height=4 * inch)

        data = [[grafico1, grafico2]]
        table = Table(data)
        story.append(table)
        story.append(Spacer(1, 6))

    if resultados:
        story.append(Paragraph("Resultados del análisis:", styles['h2']))
        for key, value in resultados.items():
            story.append(Spacer(1, 1))
            story.append(Paragraph(f"<b>{key}:</b>", styles['Normal']))

            if isinstance(value, dict):
                for subkey, subvalue in value.items():
                    if subkey == "Condición: ":
                        condicion_text = subvalue[0]
                        condicion_color = subvalue[1]
                        condicion_paragraph = Paragraph(f"{subkey}<font color='{condicion_color}'>{condicion_text}</font>", styles['Normal'])
                        story.append(condicion_paragraph)
                    else:
                        story.append(Paragraph(f"{subkey}: {subvalue}", styles['Normal']))

    if tolerancias:
        story.append(PageBreak())
        story.append(Paragraph("Tolerancias:", styles['h2']))
        for key, value in tolerancias.items():
            story.append(Spacer(1, 1))
            story.append(Paragraph(f"<b>{key}:</b>", styles['Normal']))
            if isinstance(value, dict):
                for subkey, subvalue in value.items():
                    story.append(Paragraph(f"{subkey} {subvalue}", styles['Normal']))
            else:
                story.append(Paragraph(f"{value}", styles['Normal']))
        story.append(Spacer(1, 6))

    if ecuaciones:
        story.append(Paragraph("Ecuaciones:", styles['h2']))
        for key, value in ecuaciones.items():
            story.append(Spacer(1, 4))
            story.append(Paragraph(f"{key}", styles['Normal']))
            story.append(Paragraph(f"<b>{value}</b>", styles['Normal']))
        story.append(Spacer(1, 6))

    if notas:
        story.append(Paragraph("Notas:", styles['h2']))
        for key, value in notas.items():
            story.append(Spacer(1, 1))
            story.append(Paragraph(f"<b>{key}:</b>", styles['Normal']))
            if isinstance(value, dict):
                for subkey, subvalue in value.items():
                    story.append(Paragraph(f"{subkey} {subvalue}", styles['Normal']))
            else:
                story.append(Paragraph(f"{value}", styles['Normal']))
        story.append(Spacer(1, 6))
    doc.build(story)
# Genero los datos que van a acompañar a mi pdf y el archivo.
def generar_pdf(metadata_rad, grafico_path_RadLum, grafico_path_cuadrados, resultados, titulo, tolerancias, notas, ecuaciones, logo_path, nombre_archivo_radlum, nombre_archivo_lum):
    current_datetime = datetime.datetime.now()
    formatted_datetime = current_datetime.strftime("%Y-%m-%d")
    pdf_path = os.path.join(my_directory, f"Campo Radiante - Campo Luminoso {nombre_archivo_lum} _ {nombre_archivo_radlum} _ {formatted_datetime}.pdf")
    publish_pdf(pdf_path, tolerancias=tolerancias, metadata=metadata_rad, logo=logo_path, grafico_path1=grafico_path_RadLum, grafico_path2=grafico_path_cuadrados, resultados=resultados, titulo=titulo, notas=notas, ecuaciones=ecuaciones)
    return pdf_path

def main():
# Se manda un mensaje junto con la función para seleccionar un archivo, este mensaje va
# a indicar cual es la imagen que se debe seleccionar, en este caso el luminoso.
    mensaje_luminoso = ", tiene que ser la imagen de campo luminoso solo: "
    ruta_final, nombre_archivo_Lum = seleccionar_archivo_y_verificar_extension(my_directory, mensaje_luminoso)
    imagen_lum = ruta_final
    dicom_image = pydicom.dcmread(imagen_lum)
    pixel_array = dicom_image.pixel_array

# Cargo la imagen con PicketFence para obtener el valor píxeles por mm
    pf = PicketFence(ruta_final)
    pixels_per_mm = pf.image.dpmm

# Cargo las coordenadas para recortar las ROIs con los fiduciales y obtengo: sus vértices,
# el cuadrado que contiene a los 4 fiduciales y las coordenadas x e y con las que recorto.
# Las coordenadas me sirven para cuando vuelva a la imagen original.
    coords_rois_10x10 = [(0, 10, 120, 120), (400, 10, 120, 120),
              (400, 400, 120, 120), (0, 400, 120, 120)]
    vertices_10x10, cuadrado_10x10, x_10x10, y_10x10 = procesar_fiducial(pixel_array, coords_rois_10x10, defino_e_invierto_mi_cuadrado_10x10, pixels_per_mm)
    coords_rois_20x20 = [(10, 10, 100, 100), (770, 0, 100, 100),
                    (770, 770, 100, 100), (10, 770, 100, 100)]
    vertices_20x20, cuadrado_20x20, x_20x20, y_20x20 = procesar_fiducial(pixel_array, coords_rois_20x20, defino_e_invierto_mi_cuadrado_20x20, pixels_per_mm)

# Se manda un mensaje junto con la función para seleccionar un archivo, este mensaje va
# a indicar cual es la imagen que se debe seleccionar, en este caso el radiante.
    mensaje_radLum = ", tiene que ser la imagen RadLum: "
    ruta_final_RadLum, nombre_archivo_RadLum = seleccionar_archivo_y_verificar_extension(my_directory, mensaje_radLum)
    imagen_RadLum = ruta_final_RadLum
    dicom_image_RadLum = pydicom.dcmread(imagen_RadLum)
    pixel_array_RadLum = dicom_image_RadLum.pixel_array

# Armo la imagen para el pdf, con su título correspondiente
    titulo = "Imagen del haz de X6"
    grafico_path_RadLum = imagen(pixel_array_RadLum, titulo)

# Tomo la fecha y hora de la imagen de los metadatos
    fecha_rad, hora_rad = Metadata(imagen_RadLum)
    metadata_rad = "Fecha de la imagen: " + fecha_rad + "; " + hora_rad

# Cargo las coordenadas para recortar las ROIs de los campos radiantes para calcular
# el tamaño y el centro de los mismos con la FWHM.
# Obtengo de esta manera los recortes para calcular.
    coords_rois_10x10_RadLum = [(253, 392, 524, 240, "ROI perfil invertido 10x10 ancho"),
                     (392, 253, 240, 524, "ROI perfil invertido 10x10 alto")]
    coords_rois_20x20_RadLum = [(70, 392, 880, 240, "ROI perfil invertido 20x20 ancho"),
                     (392, 70, 240, 880, "ROI perfil invertido 20x20 alto")]
    roi_perfil_inv_10x10_ancho, roi_perfil_inv_10x10_alto, roi_perfil_inv_20x20_ancho, roi_perfil_inv_20x20_alto = recortar_y_nombrar_rois_radlum(pixel_array_RadLum, coords_rois_10x10_RadLum, coords_rois_20x20_RadLum)

# Calculo el ancho, el alto y los centros y los adapto al tamaño de la imagen total.
# A partir de estos datos obtengo también los vértices de los campos.
    ancho_10x10, centro_ancho_10x10 = calcular_fwhm_y_perfil_promediado(roi_perfil_inv_10x10_ancho, orientacion='horizontal', rango_a_ignorar = None)
    alto_10x10, centro_alto_10x10 = calcular_fwhm_y_perfil_promediado(roi_perfil_inv_10x10_alto, orientacion='vertical', rango_a_ignorar = None)
    centro_10x10 = (centro_ancho_10x10 + coords_rois_10x10_RadLum[0][0], centro_alto_10x10 + coords_rois_10x10_RadLum[1][1])
    vertices_10x10_RadLum = vertices_radiantes(centro_10x10, ancho_10x10, alto_10x10)

# Calculo el rango a ignorar para el campo de 20x20 y procedo de la misma manera.
    rango_a_ignorar_ancho = calcular_rango_a_ignorar(roi_perfil_inv_20x20_ancho, orientacion='horizontal')
    rango_a_ignorar_alto = calcular_rango_a_ignorar(roi_perfil_inv_20x20_alto, orientacion='vertical')
    ancho_20x20, centro_ancho_20x20 = calcular_fwhm_y_perfil_promediado(roi_perfil_inv_20x20_ancho, orientacion='horizontal', rango_a_ignorar = rango_a_ignorar_ancho)
    alto_20x20, centro_alto_20x20 = calcular_fwhm_y_perfil_promediado(roi_perfil_inv_20x20_alto, orientacion='vertical', rango_a_ignorar = rango_a_ignorar_alto)
    centro_20x20 = (centro_ancho_20x20 + coords_rois_20x20_RadLum[0][0], centro_alto_20x20 + coords_rois_20x20_RadLum[1][1])
    vertices_20x20_RadLum = vertices_radiantes(centro_20x20, ancho_20x20, alto_20x20)

# Defino las tolerancias para los centros y vértices.
    centro_aceptable, centro_revisar, vertices_aceptable, vertices_revisar = definicion_tolerancias()

# Obtengo la imagen con el campo radiante y luminoso superpuestos para el pdf,
# obtengo los resultados.
    imagen_superpuesta, resultados = comparar_cuadrados_luminoso_vs_radiante(pixel_array_RadLum, vertices_10x10, vertices_10x10_RadLum, vertices_20x20, vertices_20x20_RadLum, x_10x10, y_10x10, x_20x20, y_20x20, pixels_per_mm, centro_aceptable, centro_revisar, vertices_aceptable, vertices_revisar)
    titulo_cuadrados = "Campo Luminoso vs Campo Radiante"
    grafico_path_cuadrados = imagen(imagen_superpuesta, titulo_cuadrados)

# Parámetros para mi pdf.
    tolerancias = Tolerancia(centro_aceptable, centro_revisar, vertices_aceptable, vertices_revisar)
    dif_lum, dif_rad = comparar_centros_cuadrados(vertices_10x10, vertices_10x10_RadLum, vertices_20x20, vertices_20x20_RadLum, x_10x10, y_10x10, x_20x20, y_20x20, pixels_per_mm)
    notas = Notas(dif_lum, dif_rad)
    logo_path = os.path.join(my_directory, 'logo.png')
    ecuaciones = Ecuaciones()

# Genero el pdf y lo descargo en el equipo.
    pdf_path = generar_pdf(metadata_rad, grafico_path_RadLum, grafico_path_cuadrados, resultados, "Análisis de Campo Radiante vs Luminoso", tolerancias, notas, ecuaciones, logo_path, nombre_archivo_RadLum, nombre_archivo_Lum)
    from google.colab import files
    files.download(pdf_path)
if __name__ == "__main__":
    main()